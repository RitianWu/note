# 变量

## 变量的内部实现

变量两个部分组成: 变量名(zval), 变量值(zend_value), PHP 中变量的内存是通过引用计数进程管理的,而且 PHP7 中引用计数是在 zend_value 上,变量之间的赋值,传递通常也是针对 zend_valur.

- zval
  - zend_value 指向值
  - u1 变量类型储存
    - type
      - IS_UNDEF
      - IS_NULL
      - IS_FALSE
      - IS_TRUE
      - IS_LONG
      - IS_DOUBLE
      - IS_STRING
      - IS_ARRAY
      - IS_OBJECT
      - IS_RESOURCE
      - IS_REFERENCE
      - IS_CONSTANT
      - IS_CONSTANT_AST
      - \_IS_BOOL
      - IS_CALLABLE
      - IS_INDIRECT
      - IS_PTR
  - u2 利用空余空间储存一些辅助值
- zend_value
  - zend\_{type} 变量类型
    - zend_long 直接储存
    - double 直接储存
    - zend_string 指针
    - zend_array 指针
    - zend_object 指针
    - zend_resource 指针
    - zend_reference 引用类型, 通过 &\$var_name 定义的
  - zend_refcounted 引用数量

最简单的类型 `true`, `false`, `long`, `double`, `null`, 其中`true`,`false`,`null`没有 value,直接根据 type 区分, 而 long,double 的值直接储存在 value 中: zend_long,double, 也就是标量类型不需要额外的 value 指针

### 字符串

PHP 中字符串通过`zend_string`表示

分为两类:

- IS_STR_PERSISTENT (通过 malloc 分配的)
- IS_STR_INTERNED (php 代码里写的一些字面量, 比如函数名,变量值)
- IS_STR_PERMANENT (永久值,生命周期大于 request)
- IS_STR_CONSTANT (常量)
- IS_STR_CONSTANT_UNQUALIFIED (通过 flag 保存)

### 数组

array 底层就是普通的有序 HashTable

### 对象/资源

对象比较常见, 资源指的是 tcp 连接, 文件句柄等等类型

### 引用

引用是 PHP 中比较特殊的类型, 它实际指向另外一个 PHP 变量, 对它的修改会直接改动实际指向的 zval, 可以简单的理解为 C 中指针

过程为:

产生一个 zend_reference(内嵌 zval) 结构,
这个结构中的 zval 的 value 指向原来的 zval 的 value(如果是布尔,整形,浮点则直接复制原来的值)
将原来的 zval 的类型修改为 IS_REFERENCE
原来的 zval 指向新创建的 zend_reference 结构

简单理解为: 引用时产生`zend_reference`, 原来变量和现在变量都指向 ref, ref 指向原来的 zend_value, 原来的 zend_value 上的 zend_value->refcount 由 ref->refcount 来负责

$a zval.value.ref zend_reference zend_string
$b zval.value.ref

引用只能通过`&`产生,无法通过赋值传递

PHP 引用只能有一层,不会出现一个引用指向另一个引用的情况

### 引用计数

引用计数是指在 value 中增加一个字段`refcount`记录指向当前 value 的数量,`变量复制,函数传参`时并不直接硬拷贝一份 value 数据,而是将`refcount++`,变量销毁时将`refcouiont--`,等到`refcount`减为 0 时,销毁即可

value 是指针的几种类型才会发生引用计数

不会发生引用计数的几种类型:

- true/false/double/long/null
- interned string(内部字符串, 所有字符都可以认为是这种类型, function name, class name, variable name, 静态字符串等, 比如 `$a = "hi"`, 后面字符串不变,生命周期为 request 期间,完成后会统一销毁释放,无需在运行期间通过引用计数管理内存)
- immutable array(只有在用 opcache 的时候才会用到这种类型)

会发生引用计数

- string
- array
- object
- resource
- reference

通过 zval.u1->type_flag 包含`IS_TYPE_REFCOUNTED`来判断是否支持引用计数

### 写时复制

引用计数表示多个变量可能指向同一个 value, 然后通过 refcount 统计引用数,如果其中一个变量试图更改 value 的内容则会重新拷贝一份 value 修改,同时断开旧的指向.

只有 string, array 两种类型支持写时复制

通过 zval.u1.type_flag 是否包含 IS_TYPE_COPYABLE 来识别是否可以写时复制

copyable 在以下两种情况下会发生

- 从 literal 变量区复制到局部变量区
- 局部变量分离时(写时复制), 如果改变变量内容引用计数大于 1 则需要分离

### 变量回收

PHP 变量主要包含两种: 主动销毁(unset), 自动销毁(在 return 时减掉局部变量的 refcount; 写时复制断开原来 value 的指向, 这时候会检查断开后旧 value 的 refcount)

### 垃圾回收

变量回收是根据 refcount 实现的, 但是有些时候变量内部引用了自身, 导致在 unset 变量时, refcount 不能归零, 这种变量就是垃圾

垃圾目前只会出现在 array, object 两种类型中, 所以会针对这两种类型做特殊处理: 当销毁的变量减掉 refcount 后仍然大于零,且类型是 IS_ARRAY IS_OBJECT 则将此 value 放入`gc可能垃圾双向列表中`,等这个链表达到一定数量后启动检查程序将所有变量检查一遍,如果确定是垃圾则销毁释放

变量是否需要回收通过 u1.type_flag 是否包含 IS_TYPE_COLLECTABLE 来识别

## 数组

## 静态变量

## 全局变量

## 常量
